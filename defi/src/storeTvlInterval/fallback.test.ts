import { describe, expect, it, jest, beforeEach } from '@jest/globals';
import { storeTvl2 } from "./getAndStoreTvl";
import { Protocol } from "../protocols/data";


// Mock the dependencies
jest.mock("../api2/db", () => ({
    getLatestProtocolItem: jest.fn(),
    getClosestProtocolItem: jest.fn(),
    saveProtocolItem: jest.fn(),
    TABLES: {
        TvlMetricsErrors2: { upsert: jest.fn() },
        TvlMetricsCompleted: { upsert: jest.fn() }
    }
}));

jest.mock("../utils/getLastRecord", () => ({
    hourlyTvl: jest.fn(),
    hourlyTokensTvl: jest.fn(),
    hourlyUsdTokensTvl: jest.fn(),
    hourlyRawTokensTvl: jest.fn(),
    dailyTvl: jest.fn(),
    dailyTokensTvl: jest.fn(),
    dailyUsdTokensTvl: jest.fn(),
    dailyRawTokensTvl: jest.fn(),
}));

jest.mock("../utils/shared/bridgedTvlPostgres", () => ({
    storeAllTokens: jest.fn(() => Promise.resolve(true))
}));

// Mock the elastic logger
jest.mock("@defillama/sdk", () => {
    const originalModule = jest.requireActual("@defillama/sdk");
    return {
        ...originalModule,
        elastic: {
            addErrorLog: jest.fn(),
            writeLog: jest.fn()
        }
    };
});

// Setup a mock module that throws on polygon by default
jest.mock("../utils/imports/importAdapter", () => ({
    importAdapterDynamic: jest.fn(() => Promise.resolve({
        ethereum: {
            tvl: jest.fn(() => Promise.resolve({ "ethereum:0x123": 100 })), // ~100M
        },
        polygon: {
            tvl: jest.fn(() => Promise.reject(new Error("RPC Failed for Polygon"))),
        }
    }))
}));

jest.mock("./computeTVL", () => {
    return jest.fn(() => Promise.resolve({
        usdTvl: 100,
        tokenBalances: { "ethereum:0x123": 100 },
        usdTokenBalances: { "ethereum:0x123": 100 }
    }));
});

jest.mock("./storeNewTvl2", () => {
    return jest.fn(() => Promise.resolve(true));
});

jest.mock("./storeNewTokensValueLocked", () => {
    return jest.fn(() => Promise.resolve(true));
});

describe("TVL Fallback Logic", () => {
    const mockProtocol: Protocol = {
        id: "test-protocol-1",
        name: "TestProtocol",
        module: "test-module",
        chains: ["ethereum", "polygon"],
        logo: null,
        url: "https://test.com",
        description: "Test description",
        audits: "0",
        category: "Dexes",
        twitter: "test",
        gecko_id: "test",
        cmcId: "123",
    };

    const mockUnixTimestamp = 1700000000;

    beforeEach(() => {
        jest.clearAllMocks();
        // explicit reset since clearAllMocks doesn't remove global mockImplementation
        require("../api2/db").getLatestProtocolItem.mockReset();
    });

    it("should fail entirely if no fallback logic is present", async () => {
        await expect(storeTvl2({
            unixTimestamp: mockUnixTimestamp,
            protocol: mockProtocol,
            useCurrentPrices: false, // Don't hit DB
            storePreviousData: false,
            fetchCurrentBlockData: false,
            skipBlockData: true, // Don't fetch real blocks
            breakIfTvlIsZero: false,
            maxRetries: 1, // Fail fast
        })).rejects.toThrow("RPC Failed for Polygon");
    });

    it("should use fallback data if a small chain fails", async () => {
        // Setup mock so that getLatestProtocolItem returns a valid DB item with a large TVL
        const mockDb = require("../api2/db");
        mockDb.getLatestProtocolItem.mockImplementation(async () => {
            return {
                SK: mockUnixTimestamp - 3600, // 1 hour ago (extremely fresh)
                tvl: 100, // Total is 100M
                polygon: 4, // Polygon is only 4M (which is < 5% of 100M)
            };
        });

        // Setup the token records mock
        const records = require("../utils/getLastRecord");
        records.hourlyTvl.mockReturnValue("hourlyTvl#123");

        const result = await storeTvl2({
            unixTimestamp: mockUnixTimestamp,
            protocol: mockProtocol,
            useCurrentPrices: false, // Don't hit DB
            storePreviousData: false,
            fetchCurrentBlockData: false,
            skipBlockData: true,
            breakIfTvlIsZero: false,
            maxRetries: 1,
            isRunFromUITool: true // returns the generated tvl object
        });

        // The overall TVL shouldn't throw, and it should return the combined results
        // 100M from ethereum (freshly mocked) + 4M from polygon (fallback)
        expect(result).toBeDefined();
        if (result && 'usdTvls' in result) {
            expect(result.usdTvls.tvl).toBe(104);
            expect(result.usdTvls.polygon).toBe(4);
            expect(result.usdTvls.ethereum).toBe(100);
        } else {
            throw new Error("Expected a return object with usdTvls");
        }
    });
});
